'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = _interopDefault(require('react'));
var classNames = _interopDefault(require('classnames'));

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var usePagination = function usePagination(_ref) {
  var currentPage = _ref.currentPage,
      setCurrentPage = _ref.setCurrentPage,
      _ref$truncableText = _ref.truncableText,
      truncableText = _ref$truncableText === void 0 ? "..." : _ref$truncableText,
      _ref$truncableClassNa = _ref.truncableClassName,
      truncableClassName = _ref$truncableClassNa === void 0 ? "" : _ref$truncableClassNa,
      totalPages = _ref.totalPages,
      _ref$edgePageCount = _ref.edgePageCount,
      edgePageCount = _ref$edgePageCount === void 0 ? 2 : _ref$edgePageCount,
      _ref$middlePagesSibli = _ref.middlePagesSiblingCount,
      middlePagesSiblingCount = _ref$middlePagesSibli === void 0 ? 1 : _ref$middlePagesSibli;
  var pages = Array(totalPages).fill(0).map(function (_, i) {
    return i + 1;
  });
  var hasPreviousPage = currentPage > 1;
  var hasNextPage = currentPage < totalPages;
  var isReachedToFirst = currentPage <= middlePagesSiblingCount;
  var isReachedToLast = currentPage + middlePagesSiblingCount >= totalPages;
  var middlePages = React.useMemo(function () {
    var middlePageCount = middlePagesSiblingCount * 2 + 1;

    if (isReachedToFirst) {
      return pages.slice(0, middlePageCount);
    }

    if (isReachedToLast) {
      return pages.slice(-middlePageCount);
    }

    return pages.slice(currentPage - middlePagesSiblingCount, currentPage + middlePagesSiblingCount + 1);
  }, [currentPage, pages]);

  var getAllPreviousPages = function getAllPreviousPages() {
    return pages.slice(0, middlePages[0] - 1);
  };

  var previousPages = React.useMemo(function () {
    if (isReachedToFirst) {
      return [];
    }

    if (getAllPreviousPages().length < 1) {
      return [];
    }

    return pages.slice(0, edgePageCount).filter(function (p) {
      return !middlePages.includes(p);
    });
  }, [currentPage, pages]);
  var getAllNextPages = React.useMemo(function () {
    return pages.slice(middlePages[middlePages.length - 1], pages[pages.length]);
  }, [pages, middlePages]);
  var nextPages = React.useMemo(function () {
    if (isReachedToLast) {
      return [];
    }

    if (getAllNextPages.length < 1) {
      return [];
    }

    return pages.slice(pages.length - edgePageCount, pages.length).filter(function (p) {
      return !middlePages.includes(p);
    });
  }, [middlePages, pages]);
  var isPreviousTruncable = React.useMemo(function () {
    // Is truncable if first value of middlePage is larger than last value of previousPages
    return middlePages[0] > previousPages[previousPages.length - 1] + 1;
  }, [previousPages, middlePages]);
  var isNextTruncable = React.useMemo(function () {
    // Is truncable if last value of middlePage is larger than first value of previousPages
    return middlePages[middlePages.length - 1] + 1 < nextPages[0];
  }, [nextPages, middlePages]);
  return {
    currentPage: currentPage,
    setCurrentPage: setCurrentPage,
    truncableText: truncableText,
    truncableClassName: truncableClassName,
    pages: pages,
    hasPreviousPage: hasPreviousPage,
    hasNextPage: hasNextPage,
    previousPages: previousPages,
    isPreviousTruncable: isPreviousTruncable,
    middlePages: middlePages,
    isNextTruncable: isNextTruncable,
    nextPages: nextPages
  };
};

var PrevButton = function PrevButton(_ref) {
  var className = _ref.className,
      children = _ref.children,
      buttonProps = _objectWithoutPropertiesLoose(_ref, ["className", "children"]);

  var pagination = React.useContext(PaginationContext);

  var previous = function previous() {
    if (pagination.currentPage + 1 > 1) {
      pagination.setCurrentPage(pagination.currentPage - 1);
    }
  };

  return React.createElement("button", Object.assign({
    className: className
  }, buttonProps, {
    onClick: function onClick() {
      return previous();
    },
    disabled: pagination.currentPage === 0
  }), children);
};
var NextButton = function NextButton(_ref2) {
  var className = _ref2.className,
      children = _ref2.children,
      buttonProps = _objectWithoutPropertiesLoose(_ref2, ["className", "children"]);

  var pagination = React.useContext(PaginationContext);

  var next = function next() {
    if (pagination.currentPage + 1 < pagination.pages.length) {
      pagination.setCurrentPage(pagination.currentPage + 1);
    }
  };

  return React.createElement("button", Object.assign({
    className: className
  }, buttonProps, {
    onClick: function onClick() {
      return next();
    },
    disabled: pagination.currentPage === pagination.pages.length - 1
  }), children);
};
var TruncableElement = function TruncableElement(_ref3) {
  var prev = _ref3.prev;
  var pagination = React.useContext(PaginationContext);
  var isPreviousTruncable = pagination.isPreviousTruncable,
      isNextTruncable = pagination.isNextTruncable,
      _pagination$truncable = pagination.truncableText,
      truncableText = _pagination$truncable === void 0 ? "..." : _pagination$truncable,
      _pagination$truncable2 = pagination.truncableClassName,
      truncableClassName = _pagination$truncable2 === void 0 ? "" : _pagination$truncable2;
  return isPreviousTruncable && prev === true || isNextTruncable && !prev ? React.createElement("span", {
    className: truncableClassName
  }, truncableText) : null;
};
var PageButton = function PageButton(_ref4) {
  var className = _ref4.className,
      _ref4$activeClassName = _ref4.activeClassName,
      activeClassName = _ref4$activeClassName === void 0 ? "" : _ref4$activeClassName,
      _ref4$inactiveClassNa = _ref4.inactiveClassName,
      inactiveClassName = _ref4$inactiveClassNa === void 0 ? "" : _ref4$inactiveClassNa;
  var pagination = React.useContext(PaginationContext);

  var renderPageButton = function renderPageButton(page) {
    var _classNames;

    return React.createElement("span", {
      key: page,
      className: classNames(className, (_classNames = {}, _classNames[activeClassName] = pagination.currentPage + 1 === page, _classNames[inactiveClassName] = pagination.currentPage + 1 !== page, _classNames)),
      onClick: function onClick() {
        return pagination.setCurrentPage(page - 1);
      }
    }, page);
  };

  return React.createElement(React.Fragment, null, pagination.previousPages.map(renderPageButton), React.createElement(TruncableElement, {
    prev: true
  }), pagination.middlePages.map(renderPageButton), React.createElement(TruncableElement, null), pagination.nextPages.map(renderPageButton));
};
var defaultState = {
  currentPage: 0,
  setCurrentPage: function setCurrentPage() {},
  truncableText: "...",
  truncableClassName: "",
  pages: [],
  hasPreviousPage: false,
  hasNextPage: false,
  previousPages: [],
  isPreviousTruncable: false,
  middlePages: [],
  isNextTruncable: false,
  nextPages: []
};
var PaginationContext = /*#__PURE__*/React.createContext(defaultState);
var Pagination = function Pagination(paginationProps) {
  var pagination = usePagination(paginationProps);
  return React.createElement(PaginationContext.Provider, {
    value: pagination
  }, React.createElement("div", {
    className: paginationProps.className
  }, paginationProps.children));
};
Pagination.PrevButton = PrevButton;
Pagination.NextButton = NextButton;
Pagination.PageButton = PageButton;

exports.NextButton = NextButton;
exports.PageButton = PageButton;
exports.Pagination = Pagination;
exports.PrevButton = PrevButton;
exports.TruncableElement = TruncableElement;
//# sourceMappingURL=react-headless-pagination.cjs.development.js.map
